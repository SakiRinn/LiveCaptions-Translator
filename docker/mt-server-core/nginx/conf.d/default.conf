server {
    listen 7878;
    server_name localhost;

    
    location /translate {
        proxy_pass http://translation-service:3000/translate;
        proxy_buffering off;  # 关闭代理缓冲

        body_filter_by_lua_block {
            -- 获取当前分块的数据
            local chunk = ngx.arg[1]
            -- 判断是否是最后一个分块
            local is_last = ngx.arg[2]

            -- 初始化 ngx.ctx.body 用于存储拼接的数据
            if not ngx.ctx.body then
                ngx.ctx.body = ""
            end

            -- 拼接当前分块的数据
            ngx.ctx.body = ngx.ctx.body .. (chunk or "")

            -- 如果是最后一个分块，处理拼接好的数据
            if is_last then
                -- 使用 cjson 库解析 JSON 数据
                local cjson = require "cjson.safe"
                local json_data, err = cjson.decode(ngx.ctx.body)
                if not json_data then
                    ngx.log(ngx.ERR, "JSON 解析失败: " .. (err or "未知错误"))
                    return
                end

                -- 修改 JSON 数据
                if json_data.text then
                    json_data.result = json_data.text
                    json_data.text = nil
                end

                -- 将修改后的 JSON 数据编码为字符串
                local modified_body, err = cjson.encode(json_data)
                if not modified_body then
                    ngx.log(ngx.ERR, "JSON 编码失败: " .. (err or "未知错误"))
                    return
                end

                -- 设置新的响应体
                ngx.arg[1] = modified_body
            end
        }

        add_header Content-Type "application/json; charset=utf-8" always;
    }
	
	location /test-lua {
        default_type text/plain;
        content_by_lua_block {
            ngx.say("Lua 模块正常工作")
        }
    }
}